#!/bin/sh -e

export ENVIRONMENTS=dev,prod
export REGION=eu-central-1
export INSTANCE_TYPE=t2.micro
export SOURCE_AMI=ami-9cee02f3
export ROOT_DOMAIN=pstylianides.com
export SSH_USERNAME=ubuntu

export GIT_REPO=git@github.com:stphivos/django-angular2-fullstack-compact.git
export GIT_BRANCH=dev

export SERVER_ROOT_NAME=webapps
export APPLICATION_NAME=fullstack
export PROJECT_NAME=backend
export SERVER_ROOT_PATH=/${SERVER_ROOT_NAME}
export APPLICATION_PATH=${SERVER_ROOT_PATH}/${APPLICATION_NAME}
export VIRTUALENV_PATH=${APPLICATION_PATH}/virtualenv
export PROJECT_PATH=${APPLICATION_PATH}/${PROJECT_NAME}

setup() {
    vagrant halt && vagrant destroy -f && vagrant up
}

build_frontend() {
    echo "Building $1 frontend..."

    cd frontend
    gulp build.$1 --color
    cd ../
}

build_backend() {
    echo "Building $1 backend..."

    export ENVIRONMENT=${1}
    export INVENTORY_LIMIT=web

    vars=$(pwd)"/provisioning/terraform/backend/${ENVIRONMENT}.packer.tfvars"
    cd provisioning/packer

    # TODO: Check rds vars json file exists
    packer build -var-file="${ENVIRONMENT}.rds.json" pack.json | \
    tee /dev/tty | \
    grep -E -o '\w{2}-\w+-\d{1}: ami-\w+' | \
    perl -ne '@parts = split /[:,\s]+/, $_; print "aws_amis." . $parts[0] ." = \"" . $parts[1] . "\"\n"' > ${vars}
    cd ../../
}

build() {
    env=$1
    project=$2

    if [[ ! ${ENVIRONMENTS} =~ ${env} ]]; then
        echo "Argument 'env' must be one of: ${ENVIRONMENTS}";
        return 1;
    fi

    case "$project" in
    frontend)
        build_frontend ${env}
        ;;
    backend)
        build_backend ${env}
        ;;
    *) echo
        build_frontend ${env}
        build_backend ${env}
       ;;
    esac
}

deploy_frontend() {
    echo "Deploying $1 frontend..."

    export ENVIRONMENT=${1}
    bucket=${ENVIRONMENT}.${ROOT_DOMAIN}

    if [ $(aws s3api list-buckets | grep -o \"${bucket}\") ]; then
        echo "Create bucket ${bucket} skipped."
    else
        aws s3api create-bucket --bucket ${bucket} --region ${REGION} --create-bucket-configuration LocationConstraint=${REGION}

        cat > /tmp/policy <<EOF
{
  "Version":"2012-10-17",
  "Statement":[{
    "Sid":"PublicReadGetObject",
    "Effect":"Allow",
    "Principal": "*",
    "Action":["s3:GetObject"],
    "Resource":["arn:aws:s3:::${bucket}/*"]
  }]
}
EOF

    policy=$(cat /tmp/policy)
    aws s3api put-bucket-policy --bucket ${bucket} --policy "$policy"
    aws s3 website s3://${bucket}/ --index-document index.html
    fi

    aws s3 cp frontend/dist/${ENVIRONMENT}/ s3://${bucket} --recursive

    cd provisioning/terraform/frontend
    terraform apply
    cd ../../
}

deploy_backend() {
    echo "Deploying $1 backend..."

    export ENVIRONMENT=${1}
    export INVENTORY_LIMIT=web

    cd provisioning/terraform/backend
    terraform apply -var-file="${ENVIRONMENT}.packer.tfvars"
    cd ../../
}

deploy_rds() {
    echo "Deploying $1 rds..."

    export ENVIRONMENT=${1}

    vars=$(pwd)"/provisioning/packer/${ENVIRONMENT}.rds.json"
    cd provisioning/terraform/rds

    terraform apply | \
        tee /dev/tty | \
        grep -E -o "db_instance_address = .+$" | \
        perl -ne '@parts = split /[=,\s]+/, $_; print "{\"db_host\"" .": \"" . $parts[1] . "\"}\n"' > ${vars}
    cd ../../
}

deploy() {
    env=$1
    project=$2

    if [[ ! ${ENVIRONMENTS} =~ ${env} ]]; then
        echo "Argument 'env' must be one of: ${ENVIRONMENTS}";
        return 1;
    fi

    case "$project" in
    frontend)
        deploy_frontend ${env}
        ;;
    backend)
        deploy_backend ${env}
        ;;
    rds)
        deploy_rds ${env}
        ;;
    *) echo
        deploy_rds ${env}
        deploy_backend ${env}
        deploy_frontend ${env}
       ;;
    esac
}

# call arguments verbatim:
$@
